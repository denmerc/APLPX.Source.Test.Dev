using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using ReactiveUI;

namespace APLPX.UI.WPF.DisplayEntities
{
    public class AnalyticValueDriverMode : ValueDriverMode
    {
        #region Private Fields

        private int _groupCount;
        private int _lowerLimit;
        private int _upperLimit;
        private bool _isAutoGenerated;

        private ObservableCollection<ValueDriverGroup> _groups;

        #endregion

        #region Constructors

        public AnalyticValueDriverMode()
        {
            Groups = new ObservableCollection<ValueDriverGroup>();
        }

        #endregion

        #region Properties

        public int GroupCount
        {
            get
            {
                //Synchronize initial values.
                if (_groupCount == 0 && _groupCount != Groups.Count)
                {
                    _groupCount = Groups.Count;
                }
                return _groupCount;
            }
            set
            {
                if (_groupCount != value)
                {
                    _groupCount = value;
                    this.RaisePropertyChanged("GroupCount");

                    //if (!IsAutoGenerated)
                    //{
                    RecalculateDriverGroups(_groupCount);
                    RecalculateEditableGroups();
                    //}
                }
            }
        }

        ///// <summary>
        ///// Gets a value indicating whether the Driver Groups under this mode are Auto-Generated.
        ///// TODO: make data-driven. This implementation is for development only.
        ///// </summary>
        //public bool IsAutoGenerated
        //{
        //    get
        //    {
        //        bool result = false;

        //        if (!String.IsNullOrWhiteSpace(Name))
        //        {
        //            result = Name.Contains("Auto Generated");
        //        }

        //        return result;
        //    }
        //}

        public bool IsAutoGenerated
        {
            get { return _isAutoGenerated; }
            set
            {
                if (_isAutoGenerated != value)
                {
                    _isAutoGenerated = value;
                    this.RaisePropertyChanged("IsAutoGenerated");
                    RecalculateEditableGroups();
                }
            }
        }

        /// <summary>
        /// Gets/sets the lower limit (applies to auto-generated driver groups only)
        /// </summary>
        public int LowerLimit
        {
            get { return _lowerLimit; }
            set { this.RaiseAndSetIfChanged(ref _lowerLimit, value); }
        }

        /// <summary>
        /// Gets/sets the upper limit (applies to auto-generated driver groups only)
        /// </summary>
        public int UpperLimit
        {
            get { return _upperLimit; }
            set { this.RaiseAndSetIfChanged(ref _upperLimit, value); }
        }

        public ObservableCollection<ValueDriverGroup> Groups
        {
            get { return _groups; }
            set
            {
                if (_groups != value)
                {
                    _groups = value;
                    this.RaisePropertyChanged("Groups");
                    RecalculateEditableGroups();
                }
            }
        }

        #endregion

        #region Methods

        private void RecalculateDriverGroups(int newGroupCount)
        {
            //Add new groups
            for (int index = Groups.Count; index <= newGroupCount; index++)
            {
                int defaultMaxOutlier = 0;
                if (index > 0)
                {
                    //Set the default based on the previous group's minimum outlier.
                    ValueDriverGroup previousGroup = Groups[index - 1];
                    defaultMaxOutlier = Convert.ToInt32(previousGroup.MinOutlier - 1);
                }

                short groupValue = Convert.ToInt16(index + 1);
                Groups.Add(new ValueDriverGroup { Value = groupValue, MinOutlier = 0M, MaxOutlier = defaultMaxOutlier });
            }

            //Remove existing groups
            for (int index = Groups.Count - 1; index >= newGroupCount; index--)
            {
                Groups.RemoveAt(index);
            }
        }

        /// <summary>
        /// Simulates a server-side auto calculation of value driver groups.
        /// NOTE: FOR DEV AND TESTING ONLY.
        /// </summary>
        public void MockAutoCalculateDriverGroups()
        {
            //TODO: simulation only. In production, the server will perform the actual calculations.
            var firstGroup = Groups[0];
            var lastGroup = Groups[Groups.Count - 1];

            decimal upperLimit = firstGroup.MaxOutlier;
            if (upperLimit == 0)
            {
                upperLimit = 1000M;
            }
            decimal lowerLimit = lastGroup.MinOutlier;
            decimal delta = (upperLimit - lowerLimit) / Groups.Count;

            //Distribute the ranges among each group.
            for (int i = 0; i < Groups.Count; i++)
            {
                Groups[i].MaxOutlier = Math.Round(upperLimit, 0);
                if (i > 0)
                {
                    Groups[i].MaxOutlier -= 1;
                }
                Groups[i].MinOutlier = Math.Round((upperLimit - delta), 0);
                upperLimit -= delta;
            }
        }

        public void RecalculateEditableGroups()
        {
            if (IsAutoGenerated)
            {
                //Only the first group's Maximum and last group's Minimum are editable.
                SetAllGroupsEditable(false);
                Groups[0].IsMaxValueEditable = true;
                Groups[Groups.Count - 1].IsMinValueEditable = true;
            }
            else
            {
                SetAllGroupsEditable(true);
            }
        }

        private void SetAllGroupsEditable(bool isEditable)
        {
            foreach (ValueDriverGroup group in Groups)
            {
                group.IsMaxValueEditable = isEditable;
                group.IsMinValueEditable = isEditable;
            }
        }

        #endregion
    }
}
