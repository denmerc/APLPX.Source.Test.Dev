using System;
using System.Reactive.Linq;
using ReactiveUI;

namespace APLPX.UI.WPF.DisplayEntities
{
    public class AnalyticValueDriverMode : ValueDriverMode, IDisposable
    {
        #region Private Fields

        private int _groupCount;
        private ReactiveList<AnalyticValueDriverGroup> _groups;
        private bool _areResultsAvailable;

        private IDisposable _drivergroupChangedListener;
        private bool _isDisposed;

        #endregion

        #region Constructors

        public AnalyticValueDriverMode()
        {
            Groups = new ReactiveList<AnalyticValueDriverGroup>();

            Groups.ChangeTrackingEnabled = true;
            _drivergroupChangedListener = Groups.ItemChanged.Subscribe(grp => OnDriverGroupValuesChanged(grp));
        }

        #endregion

        #region Properties

        public int GroupCount
        {
            get
            {
                //Synchronize initial values.
                if (_groupCount == 0 && _groupCount != Groups.Count)
                {
                    _groupCount = Groups.Count;
                }
                return _groupCount;
            }
            set
            {
                if (_groupCount != value)
                {
                    _groupCount = value;
                    this.RaisePropertyChanged("GroupCount");

                    RecalculateDriverGroups(_groupCount);
                    RecalculateEditableGroups();
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether the Driver Groups under this mode are Auto-Generated.
        /// TODO: make data-driven. This implementation is for development only.
        /// </summary>
        public bool IsAutoGenerated
        {
            get
            {
                bool result = false;

                if (!String.IsNullOrWhiteSpace(Name))
                {
                    result = Name.Contains("Auto Generated");
                }

                return result;
            }
        }

        public ReactiveList<AnalyticValueDriverGroup> Groups
        {
            get { return _groups; }
            set
            {
                if (_groups != value)
                {
                    _groups = value;
                    this.RaisePropertyChanged("Groups");
                    RecalculateEditableGroups();
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether calculated results for this mode's value driver groups are available.
        /// This depends on whether any of the groups has changes since the last calculation (Run).
        /// Bound views can use this property to show/hide results, etc.
        /// </summary>
        public bool AreResultsAvailable
        {
            get { return _areResultsAvailable; }
            set { this.RaiseAndSetIfChanged(ref _areResultsAvailable, value); }
        }

        #endregion

        #region Methods

        private void RecalculateDriverGroups(int newGroupCount)
        {
            //Add new groups
            for (int index = Groups.Count; index <= newGroupCount; index++)
            {
                int defaultMaxOutlier = 0;
                if (index > 0)
                {
                    //Set the default based on the previous group's minimum outlier.
                    ValueDriverGroup previousGroup = Groups[index - 1];
                    defaultMaxOutlier = Convert.ToInt32(previousGroup.MinOutlier - 1);
                }

                short groupValue = Convert.ToInt16(index + 1);
                Groups.Add(new AnalyticValueDriverGroup { Value = groupValue, MinOutlier = 0, MaxOutlier = defaultMaxOutlier });
            }

            //Remove existing groups
            for (int index = Groups.Count - 1; index >= newGroupCount; index--)
            {
                Groups.RemoveAt(index);
            }
        }

        public void RecalculateEditableGroups()
        {
            if (IsAutoGenerated)
            {
                //Only the first group's Maximum and last group's Minimum are editable.
                SetAllGroupsEditable(false);
                Groups[0].IsMaxValueEditable = true;
                Groups[Groups.Count - 1].IsMinValueEditable = true;
            }
            else
            {
                SetAllGroupsEditable(true);
            }
        }

        /// <summary>
        /// Detects property changes to any Value Driver Group contained within this Mode.
        /// </summary>
        private void OnDriverGroupValuesChanged(IReactivePropertyChangedEventArgs<AnalyticValueDriverGroup> args)
        {
            var driverGroup = args.Sender as AnalyticValueDriverGroup;
            if (driverGroup != null)
            {
                this.RaisePropertyChanged(args.PropertyName);
            }
        }

        private void SetAllGroupsEditable(bool isEditable)
        {
            foreach (var group in Groups)
            {
                group.IsMaxValueEditable = isEditable;
                group.IsMinValueEditable = isEditable;
            }
        }

        #endregion

        #region Overrides

        public override string ToString()
        {
            string result = String.Format("{0}:Name={1};Key={2};IsSelected={3}", GetType().Name, Name, Key, IsSelected);

            return result;
        }

        #endregion

        #region For Development and Testing Only

        /// <summary>
        /// Simulates a server-side auto calculation of value driver groups.
        /// NOTE: FOR DEV AND TESTING ONLY.
        /// </summary>
        public void MockAutoCalculateDriverGroups()
        {
            //TODO: simulation only. In production, the server will perform the actual calculations.
            var firstGroup = Groups[0];
            var lastGroup = Groups[Groups.Count - 1];

            decimal upperLimit = firstGroup.MaxOutlier;
            if (upperLimit == 0)
            {
                upperLimit = 1000;
            }
            decimal lowerLimit = lastGroup.MinOutlier;
            int delta = Convert.ToInt32((upperLimit - lowerLimit) / (decimal)Groups.Count);

            //Distribute the ranges among each group.
            for (int i = 0; i < Groups.Count; i++)
            {
                Groups[i].MaxOutlier = upperLimit;
                if (i > 0)
                {
                    Groups[i].MaxOutlier -= 1;
                }
                Groups[i].MinOutlier = upperLimit - delta;
                upperLimit -= delta;
            }
        }

        #endregion

        #region IDisposable

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool isDisposing)
        {
            if (!_isDisposed)
            {
                if (isDisposing)
                {
                    if (_drivergroupChangedListener != null)
                    {
                        _drivergroupChangedListener.Dispose();
                        _drivergroupChangedListener = null;
                    }
                    if (Groups != null)
                    {
                        Groups.ChangeTrackingEnabled = false;
                    }
                }
                _isDisposed = true;
            }
        }

        #endregion
    }
}
