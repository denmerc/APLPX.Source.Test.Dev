using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using ReactiveUI;

namespace APLPX.UI.WPF.DisplayEntities
{
    public class DriverMode : DisplayEntityBase
    {
        #region Private Fields

        private int _key;
        private string _name;
        private short _sort;
        private string _title;
        private bool _isSelected;
        private int _groupCount;
        private int _lowerLimit;
        private int _upperLimit;


        private ObservableCollection<DriverGroup> _groups;

        #endregion

        #region Constructors

        public DriverMode()
        {
            Groups = new ObservableCollection<DriverGroup>();
        }

        #endregion

        #region Properties

        public int Key
        {
            get { return _key; }
            set { this.RaiseAndSetIfChanged(ref _key, value); }
        }

        public string Name
        {
            get { return _name; }
            set { this.RaiseAndSetIfChanged(ref _name, value); }
        }

        public short Sort
        {
            get { return _sort; }
            set { this.RaiseAndSetIfChanged(ref _sort, value); }
        }

        public string Title
        {
            get { return _title; }
            set { this.RaiseAndSetIfChanged(ref _title, value); }
        }

        public bool IsSelected
        {
            get { return _isSelected; }
            set { this.RaiseAndSetIfChanged(ref _isSelected, value); }
        }

        public int GroupCount
        {
            get
            {
                //Synchronize initial values.
                if (_groupCount == 0 && _groupCount != Groups.Count)
                {
                    _groupCount = Groups.Count;
                }
                return _groupCount;
            }
            set
            {
                if (_groupCount != value)
                {
                    _groupCount = value;
                    this.RaisePropertyChanged("GroupCount");

                    if (!IsAutoGenerated)
                    {
                        RecalculateDriverGroups(_groupCount); 
                    }
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether the Driver Groups under this mode are Auto-Generated.
        /// TODO: make data-driven. This implementation is for development only.
        /// </summary>
        public bool IsAutoGenerated
        {
            get
            {
                bool result = false;

                if (!String.IsNullOrWhiteSpace(Name))
                {
                    result = Name.Contains("Auto Generated");
                }                

                return result;
            }

        }

        /// <summary>
        /// Gets/sets the lower limit (applies to auto-generated driver groups only)
        /// </summary>
        public int LowerLimit
        {
            get { return _lowerLimit; }
            set { this.RaiseAndSetIfChanged(ref _lowerLimit, value); }
        }

        /// <summary>
        /// Gets/sets the upper limit (applies to auto-generated driver groups only)
        /// </summary>
        public int UpperLimit
        {
            get { return _upperLimit; }
            set { this.RaiseAndSetIfChanged(ref _upperLimit, value); }
        }

        public ObservableCollection<DriverGroup> Groups
        {
            get { return _groups; }
            set { this.RaiseAndSetIfChanged(ref _groups, value); }
        }

        #endregion

        #region Methods

        private void RecalculateDriverGroups(int newGroupCount)
        {
            //Add new groups
            for (int index = Groups.Count; index <= newGroupCount; index++)
            {                
                int defaultMaxOutlier = 0;
                if (index > 0)
                {
                    //Set the default based on the previous group's minimum outlier.
                    DriverGroup previousGroup = Groups[index - 1];
                    defaultMaxOutlier = Convert.ToInt32(previousGroup.MinOutlier - 1);
                }

                short groupValue = Convert.ToInt16(index + 1);
                Groups.Add(new DriverGroup { Value = groupValue, MinOutlier = 0M, MaxOutlier = defaultMaxOutlier });
            }

            //Remove existing groups
            for (int index = Groups.Count - 1; index >= newGroupCount; index--)
            {
                Groups.RemoveAt(index);
            }
        }


        #endregion
    }
}
