using System;
using ReactiveUI;

namespace APLPX.UI.WPF.DisplayEntities
{
    public class AnalyticValueDriverMode : ValueDriverMode, IDisposable
    {
        #region Private Fields

        private int _groupCount;
        private ReactiveList<AnalyticValueDriverGroup> _groups;
        private int _minDriverOutlier;
        private int _maxDriverOutlier;
        private bool _areResultsAvailable;

        private IDisposable _drivergroupChangedListener;
        private bool _isDisposed;

        #endregion

        #region Constructors

        public AnalyticValueDriverMode()
        {
            Groups = new ReactiveList<AnalyticValueDriverGroup>();

            Groups.ChangeTrackingEnabled = true;
            _drivergroupChangedListener = Groups.ItemChanged.Subscribe(grp => OnDriverGroupValuesChanged(grp));
        }

        #endregion

        #region Properties

        public int GroupCount
        {
            get
            {
                //Synchronize initial values.
                if (_groupCount == 0 && _groupCount != Groups.Count)
                {
                    _groupCount = Groups.Count;
                }
                return _groupCount;
            }
            set
            {
                if (_groupCount != value)
                {
                    _groupCount = value;
                    this.RaisePropertyChanged("GroupCount");

                    RecalculateDriverGroups(_groupCount);
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether the Driver Groups under this mode are Auto-Generated.
        /// TODO: make data-driven. This implementation is for development only.
        /// </summary>
        public bool IsAutoGenerated
        {
            get
            {
                bool result = false;

                if (!String.IsNullOrWhiteSpace(Name))
                {
                    result = Name.Contains("Auto Generated");
                }

                return result;
            }
        }

        public ReactiveList<AnalyticValueDriverGroup> Groups
        {
            get { return _groups; }
            set
            {
                if (_groups != value)
                {
                    _groups = value;
                    this.RaisePropertyChanged("Groups");
                    RecalculateEditableGroups();
                }
            }
        }

        /// <summary>
        /// Gets/sets the minimum outlier value for any value driver group within this mode.
        /// Note: this property is at the value driver level; each group within the driver has its own minimum outlier value.
        /// </summary>
        public int MinDriverOutlier
        {
            get { return _minDriverOutlier; }
            set
            {
                if (_minDriverOutlier != value)
                {
                    _minDriverOutlier = value;
                    OnPropertyChanged("MinDriverOutlier");

                    if (IsAutoGenerated)
                    {
                        UpdateAutoGroupValues();
                    }
                    //RecalculateEditableGroups();
                }
            }
        }

        /// <summary>
        /// Gets/sets the maximum value for any value driver group within this mode.
        /// Note: this property is at the value driver level; each group within the driver has its own maximum outlier value.
        /// </summary>
        public int MaxDriverOutlier
        {
            get { return _maxDriverOutlier; }
            set
            {
                if (_maxDriverOutlier != value)
                {
                    _maxDriverOutlier = value;
                    OnPropertyChanged("MaxDriverOutlier");
                    if (IsAutoGenerated)
                    {
                        UpdateAutoGroupValues();
                    }
                    //RecalculateEditableGroups();
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether calculated results for this mode's value driver groups are available.
        /// This depends on whether any of the groups has changes since the last calculation (Run).
        /// Bound views can use this property to show/hide results, etc.
        /// </summary>
        public bool AreResultsAvailable
        {
            get { return _areResultsAvailable; }
            set { this.RaiseAndSetIfChanged(ref _areResultsAvailable, value); }
        }

        #endregion

        #region Methods

        private void RecalculateDriverGroups(int newGroupCount)
        {
            //Add new groups
            for (int index = Groups.Count; index <= newGroupCount; index++)
            {
                int defaultMaxOutlier = 0;
                if (index > 0)
                {
                    //Set the default based on the previous group's minimum outlier.
                    ValueDriverGroup previousGroup = Groups[index - 1];
                    defaultMaxOutlier = Convert.ToInt32(Math.Max(0, previousGroup.MinOutlier - 1));
                }

                short groupValue = Convert.ToInt16(index + 1);
                Groups.Add(new AnalyticValueDriverGroup { Value = groupValue, MinOutlier = 0, MaxOutlier = defaultMaxOutlier });
            }

            //Remove existing groups
            for (int index = Groups.Count - 1; index >= newGroupCount; index--)
            {
                Groups.RemoveAt(index);
            }

            //Sync max and min with first and last auto groups.
            if (IsAutoGenerated)
            {
                UpdateAutoGroupValues();
            }

            RecalculateEditableGroups();
        }

        private void UpdateAutoGroupValues()
        {
            if (Groups.Count > 0)
            {
                Groups[0].MaxOutlier = MaxDriverOutlier;
                Groups[Groups.Count - 1].MinOutlier = MinDriverOutlier;
            }
        }

        public void RecalculateEditableGroups()
        {
            if (Groups != null && Groups.Count > 0)
            {
                var firstGroup = Groups[0];
                //TODO: determine rules for applying cutoff to individual group values.
                //firstGroup.MaxOutlier = Math.Min(firstGroup.MaxOutlier, HighCutoff);

                var lastGroup = Groups[Groups.Count - 1];
                //TODO: determine rules for applying cutoff to individual group values.
                //lastGroup.MinOutlier = Math.Max(lastGroup.MinOutlier, LowCutoff);

                if (IsAutoGenerated)
                {
                    //Only the first group's Maximum and last group's Minimum are editable.
                    SetAllGroupsEditable(false);
                    firstGroup.IsMaxValueEditable = true;
                    lastGroup.IsMinValueEditable = true;
                }
                else
                {
                    //First group is always editable.
                    firstGroup.IsMaxValueEditable = true;
                    firstGroup.IsMinValueEditable = true;

                    for (int i = 1; i < Groups.Count; i++)
                    {
                        //Each succeeding group's values and editabilty depend on the previous group.
                        AnalyticValueDriverGroup group = Groups[i];

                        //Max outlier is only editable for the first group.
                        group.IsMaxValueEditable = false;
                        group.MaxOutlier = Math.Max(0, Groups[i - 1].MinOutlier - 1);
                        if (group.MaxOutlier == 0)
                        {
                            group.MinOutlier = 0;
                        }
                        group.IsMinValueEditable = (group.MaxOutlier > 0);
                    }
                }
            }
        }

        /// <summary>
        /// Detects property changes to any Value Driver Group contained within this Mode.
        /// </summary>
        private void OnDriverGroupValuesChanged(IReactivePropertyChangedEventArgs<AnalyticValueDriverGroup> args)
        {
            var driverGroup = args.Sender as AnalyticValueDriverGroup;
            if (driverGroup != null)
            {
                if (driverGroup.IsDirty)
                {
                    IsDirty = true;
                }
                this.RaisePropertyChanged(args.PropertyName);
                if (args.PropertyName == "MinOutlier" || args.PropertyName == "MaxOutlier")
                {
                    RecalculateEditableGroups();
                }
            }
        }

        private void SetAllGroupsEditable(bool isEditable)
        {
            foreach (var group in Groups)
            {
                group.IsMaxValueEditable = isEditable;
                group.IsMinValueEditable = isEditable;
            }
        }

        #endregion

        #region Overrides

        public override string ToString()
        {
            string result = String.Format("{0}:Name={1};Key={2};IsSelected={3}", GetType().Name, Name, Key, IsSelected);

            return result;
        }

        #endregion

        #region For Development and Testing Only

        /// <summary>
        /// Simulates a server-side auto calculation of value driver groups.
        /// NOTE: FOR DEV AND TESTING ONLY.
        /// </summary>
        public void MockAutoCalculateDriverGroups()
        {
            //TODO: simulation only. In production, the server will perform the actual calculations.
            var firstGroup = Groups[0];
            var lastGroup = Groups[Groups.Count - 1];

            decimal upperLimit = firstGroup.MaxOutlier;
            if (upperLimit == 0)
            {
                upperLimit = 1000;
            }
            decimal lowerLimit = lastGroup.MinOutlier;
            int delta = Convert.ToInt32((upperLimit - lowerLimit) / (decimal)Groups.Count);

            //Distribute the ranges among each group.
            for (int i = 0; i < Groups.Count; i++)
            {
                Groups[i].MaxOutlier = upperLimit;
                if (i > 0)
                {
                    Groups[i].MaxOutlier -= 1;
                }
                Groups[i].MinOutlier = upperLimit - delta;
                upperLimit -= delta;
            }
        }

        #endregion

        #region IDisposable

        protected override void Dispose(bool isDisposing)
        {
            if (!_isDisposed)
            {
                if (isDisposing)
                {
                    if (_drivergroupChangedListener != null)
                    {
                        _drivergroupChangedListener.Dispose();
                        _drivergroupChangedListener = null;
                    }
                    if (Groups != null)
                    {
                        Groups.ChangeTrackingEnabled = false;
                    }
                }
                _isDisposed = true;
            }

            base.Dispose(isDisposing);
        }

        #endregion
  
    }
}
